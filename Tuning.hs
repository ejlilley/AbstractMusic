{-# LANGUAGE EmptyDataDecls, 
             MultiParamTypeClasses, 
             UndecidableInstances, 
             IncoherentInstances, 
             DataKinds,
             FunctionalDependencies,
             FlexibleContexts,
             RankNTypes,
             OverlappingInstances,
             TypeSynonymInstances,
             ScopedTypeVariables,
             UnicodeSyntax,
             GADTSyntax,
             GADTs,
             TypeFamilies,
             ConstraintKinds,
             InstanceSigs,
             GeneralizedNewtypeDeriving,
             StandaloneDeriving,
             ViewPatterns,
             FlexibleInstances #-}

module Tuning (Tuning(..),
               equal,
               septimal,
               schismatic,
               kleismic,
               synTET5,
               synTET7,
               synTET12,
               synTET19,
               synTET31,
               synTET53,
               ArbitrarySyntonic(..),
               TET17(..),
               TET22(..),
               TET24(..),
               TET72(..),
               ArbitraryTET(..),
               edo,
               edoTune,
               synTune,
               pythagorean,
               qcmeantone,
               scmeantone,
               tcmeantone,
               inverted,
               DummyTuning(..)) where

import Prelude hiding (negate)

import Debug.Trace

import Util (sortUnder, sortPairs)

import Music (Name(..), Accidental(..),
              Quality(..), Number(..),
              AbstractPitch3(..), AbstractInt3(..), AbstractDur3(..),
              AbstractPitch2(..), AbstractInt2(..), AbstractDur2(..),
              AbstractNote(..), Note, Tuning(..), Transpose(..),
              Freq, add, sub, invert, negate, transpose, interval, octave,
              faInt, faPitch, FreeAbelian(..), intToFa, pitchToFa, toInterval,
              toPitch, cent)

import Algebra
import Shortcuts


-- return an equal division of the octave
edo :: Int -> AbstractInt3
edo n = octave ^* (1/(fromIntegral n))

cents :: AbstractInt3 -> Double
cents (AbstractInt3 f) = (log f) / (log cent)

-- Generic function for EDO tunings -- i.e. one generator for the
-- whole scale, but utilising the representation of intervals as n*A1
-- + m*d2 (by some linear transformation) to number the resulting
-- degrees of the scale (Rank 1 tuning systems)
edoTune :: AbstractInt3 -> (Int, Int) -> AbstractInt2 -> AbstractInt3
edoTune d (x, y) (AbstractInt2 q n) =
  let a ::+ b = faInt q n
  in (fromIntegral (x*a + y*b)) *^ d

-- Generic function for tunings that are based on fixing the value of
-- two intervals -- i.e. two generators for the whole scale (Rank 2
-- (syntonic) tuning systems)
synTune :: AbstractInt3 -> AbstractInt3 -> AbstractInt2 -> AbstractInt3
synTune a1rat d2rat (AbstractInt2 q n) =
  let a1 ::+ d2 = faInt q n
  in (a1rat ^* (fromIntegral a1)) ^+^ (d2rat ^* (fromIntegral d2))

-- For rank-3 tuning systems (specifically five-limit aka just
-- intonation), see FiveLimit.hs (experimental).

makeBasis i (i1, r1) (i2, r2) = case (intervalDivisorsFrac i i1 i2) of
--   Just (x, y) -> AbstractInt3 $ r1**x * r2**y
  Just (x, y) -> (x *^ r1) ^+^ (y *^ r2)
  Nothing -> error ("Cannot use intervals " ++ (show i1) ++ " and " ++ (show i2) ++ " as basis pair to represent " ++ (show i))

makeA1 = makeBasis _A1
maked2 = makeBasis d2


-- All intervals become unison, so all pitches sound the same
data DummyTuning = DummyTuning (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning DummyTuning AbstractPitch2 AbstractInt2 where
  base (DummyTuning b) = b
  tuneInt _ _ = AbstractInt3 1


---- Syntonic (aka meantone) tunings

-- A note about the syntonic tunings described here: In the real
-- world, when these syntonic/meantone tunings are used on e.g. a
-- keyboard, the number of notes generated by the tuning system has to
-- be fixed to some finite number (typically 12, for normal
-- keyboards). The synTune function below will, however, merrily
-- generate perfectly correct notes/intervals of every kind in every
-- key, producing results that would be impossible in real life (you
-- cannot have a keyboard with a (countably) infinite number of
-- keys). E.g. there is a correct way to tune C-double-sharp (or a
-- doubly-diminished-sixth or what have you) in Pythagorean tuning,
-- but you would never encounter this note unless someone had decided
-- that they *really* wanted a C-double-sharp on their keyboard
-- instead of a D. Therefore, to more accurately represent real-world
-- usage, it may be desirable to write a version of synTune that
-- arbitrarily cut off the number of different notes generated by a
-- particular tuning system (and maybe to give a description of the
-- cutting-off-point(s) as a parameter of the tuning system's type
-- constructor).


pureoctave = ArbitrarySyntonic (_P8, rat 2)

pythagorean = pureoctave (_P5,      rat $ 3/2) -- the Pythagorean d4 and A2 are fairly close to the just M3 and m3, respectively (see schismatic)
qcmeantone  = pureoctave (_M3,      rat $ 5/4)
scmeantone  = pureoctave (_A4,      rat $ 45/32)
tcmeantone  = pureoctave (m3,       rat $ 6/5)
septimal    = pureoctave (_A6,      rat $ 7/4)
schismatic  = pureoctave (8 *^ _P4, rat $ 10) -- gives you just major thirds as the interval d4, and just minor thirds as A2.
kleismic    = pureoctave (6 *^ m3,  rat $ 3) -- this might be wrong
augmented   = pureoctave (3 *^ _M3, rat $ 2)
pelogic     = pureoctave (4 *^ _P5, rat $ 24/5)
wuerschmidt = pureoctave (8 *^ _M3, rat $ 6)
dimipent    = pureoctave (4 *^ m3,  rat $ 2)
dicot       = pureoctave (_A1,      rat $ 1) -- i.e. TET7
tetracot    = pureoctave (_A5,      rat $ 3/2)
sycamore    = pureoctave (5 *^ _A1, rat $ 6/5)
escapade    = pureoctave (9 *^ _M3, rat $ 16384 / 2187)
vishnuzmic  = pureoctave (7 *^ _A1, rat $ 4/3)
inverted    = pureoctave (_P5,      rat $ 4/3) -- swap fourths and fifths
synTET5     = pureoctave (m2,       rat $ 1)
synTET7     = pureoctave (_A1,      rat $ 1)
synTET12    = pureoctave (d2,       rat $ 1) -- TET12 is an excellent approximation to Pythagorean tuning, and is also very good overall at harmonic-matching. It's *not* as close to Just intonation as many of the Meantone temperaments, however.
synTET19    = pureoctave (dd2,      rat $ 1) where dd2 = d2 ^-^ _A1 -- same but with TET19
synTET31    = pureoctave (dddd3,    rat $ 1) where dddd3 = m3 ^-^ (4 *^ _A1)
synTET53    = pureoctave (ddddddd6, rat $ 1) where ddddddd6 = 31 *^ _P8 ^-^ 53 *^ _P5 -- is "schismatic", in that d4 is closer to 5/4 than M3

-- Any tuning involving setting an interval to 1 ("tempering" it out)
-- is a projection to a rank-1 tuning -- essentially, the function
-- 'genericEdo' is automatically determining the interval to temper
-- out.

pureFifthsThirds = ArbitrarySyntonic (_P5, rat $ 3/2) (_M3, rat $ 5/4) -- pure fifths and thirds, but not octaves(!)


data ArbitrarySyntonic = ArbitrarySyntonic
                         (AbstractInt2, AbstractInt3)
                         (AbstractInt2, AbstractInt3)
                         (AbstractPitch2, AbstractPitch3) deriving Show

instance Tuning ArbitrarySyntonic AbstractPitch2 AbstractInt2 where
  base (ArbitrarySyntonic _ _ b) = b
  tuneInt (ArbitrarySyntonic int1 int2 b) = synTune (makeA1 int1 int2) (maked2 int1 int2)



---- Equal-division-of-the-octave (aka TET aka EDO) tunings

-- By analogy with the note about syntonic tuning systems given above,
-- the n-TET tuning systems here are obviously only applicable to
-- keyboards with n different keys -- hence 12-TET being the only one
-- in common usage (but see Costeley.lhs for an interesting 19-TET
-- example). "Meantone"-type TET tunings can be expressed as syntonic
-- tunings (see synTET5, synTET7 etc. above). The irregular ones are
-- implemented here, using the edoTune function.


equal = synTET12

-- data TET17 -- todo: implement the arabic system of notation/scales,
-- then use TET17 as its tuning system.
data TET17 = TET17 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET17 AbstractPitch2 AbstractInt2 where
  base (TET17 b) = b
  tuneInt _ = edoTune (edo 17) (2, -1)

-- data Indian22 -- todo: implement the Indian system of notation/scales,
-- then use this as its tuning system.

-- the EDO-version of Indian22 above (maybe)
data TET22 = TET22 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET22 AbstractPitch2 AbstractInt2 where
  base (TET22 b) = b
  tuneInt _ = edoTune (edo 22) (3, -2)

-- TET12 + quarter-tones:
data TET24 = TET24 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET24 AbstractPitch2 AbstractInt2 where
  base (TET24 b) = b
  tuneInt _ = edoTune (edo 24) (2, 0)


data TET34 = TET34 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET34 AbstractPitch2 AbstractInt2 where
  base (TET34 b) = b
  tuneInt _ = edoTune (edo 34) (4, -2)

data TET41 = TET41 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET41 AbstractPitch2 AbstractInt2 where
  base (TET41 b) = b
  tuneInt _ = edoTune (edo 41) (4, -1)

-- TET12 divided by 6:
data TET72 = TET72 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET72 AbstractPitch2 AbstractInt2 where
  base (TET72 b) = b
  tuneInt _ = edoTune (edo 72) (6, 0)

data TET94 = TET94 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET94 AbstractPitch2 AbstractInt2 where
  base (TET94 b) = b
  tuneInt _ = edoTune (edo 94) (9, -2)
--  tuneInt _ = edoTune (edo 94) (2, 10)


data TET118 = TET118 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET118 AbstractPitch2 AbstractInt2 where
  base (TET118 b) = b
  tuneInt _ = edoTune (edo 118) (11, -2)


---- EDO helper functions:

memo f = let table = [ (x, f x) | x <- [0..] ]
         in  \y -> let Just r = lookup y table in r

-- An example of how to find (x,y) values for EDO tunings
findEdo = memo f where
  f d = sortPairs $ filter (\(x,y) -> 12*x + 7*y == d) [(x,y) | x <- [-100..100], y <- [-100..100]]

deriveEdo d =
  case findEdo d of
  p:ps -> p
  [] -> error $ "No edo solutions for " ++ (show d)

genericEdo d = edoTune (edo d) (deriveEdo d)

edoSearch n i = sortUnder snd $ map (\x -> (x, (flip genericEdo) i $ x)) [0..n]
-- search for a good edo for matching M3 with: edoSearch _M3

-- Not guaranteed to pick the best mapping of pitches onto the edo scale:
data ArbitraryTET = ArbitraryTET Int (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning ArbitraryTET AbstractPitch2 AbstractInt2 where
  base (ArbitraryTET d b) = b
  tuneInt (ArbitraryTET d b) = genericEdo d


-- The procedure for mapping intervals to note-numbering in each
-- particular EDO is suited to finding good approximations to
-- Pythagorean tuning.  This is sub-optimal for tunings (such as
-- 53-TET) which are also capable of simultaneously matching two just
-- intervals well e.g. the 5/4 just major third as well as a perfect
-- fifth. For 53-TET, you could just be happy spelling your just major
-- thirds as diminished fourths.


tet106 = ArbitraryTET 106 -- next best for matching P5 = 3/2
tet174 = ArbitraryTET 174 -- next best for matching M3 = 5/4, also matches P5 well
tet62 = ArbitraryTET 62 -- good for matching both P5 and M3
