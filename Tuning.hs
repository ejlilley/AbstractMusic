{-# LANGUAGE EmptyDataDecls, 
             MultiParamTypeClasses, 
             UndecidableInstances, 
             IncoherentInstances, 
             DataKinds,
             FunctionalDependencies,
             FlexibleContexts,
             RankNTypes,
             OverlappingInstances,
             TypeSynonymInstances,
             ScopedTypeVariables,
             UnicodeSyntax,
             GADTSyntax,
             GADTs,
             TypeFamilies,
             ConstraintKinds,
             InstanceSigs,
             GeneralizedNewtypeDeriving,
             StandaloneDeriving,
             ViewPatterns,
             FlexibleInstances #-}

module Tuning (Tuning(..),
               Pythagorean(..),
               Equal(..),
               equal,
               QCMeanTone(..),
               SCMeanTone(..),
               septimal,
               schismatic,
               kleismic,
               ArbitrarySyntonic(..),
               TET7(..),
               TET12(..),
               TET17(..),
               TET19(..),
               TET22(..),
               TET24(..),
               TET31(..),
               TET54(..),
               TET72(..),
               edo,
               DummyTuning(..)) where

import Prelude hiding (negate)

import Util (interleave)

import Music (Name(..), Accidental(..),
              Quality(..), Number(..),
              AbstractPitch3(..), AbstractInt3(..), AbstractDur3(..),
              AbstractPitch2(..), AbstractInt2(..), AbstractDur2(..),
              AbstractNote(..), Note, Tuning(..), Transpose(..),
              Freq, add, sub, invert, negate, transpose, interval, octave,
              faInt, faPitch, FreeAbelian(..), intToFa, pitchToFa, toInterval,
              toPitch, cent)

import Algebra
import Shortcuts


-- return an equal division of the octave
edo :: Int -> AbstractInt3
edo n = octave ^* (1/(fromIntegral n))

cents :: AbstractInt3 -> Double
cents (AbstractInt3 f) = (log f) / (log cent)

-- An example of how to find (x,y) values for EDO tunings
findEdo d = filter (\(x,y) -> 12*x + 7*y == d) [(x,y) | x <- [-10..10], y <- [-10..10]]

-- Generic function for EDO tunings -- i.e. one generator for the
-- whole scale, but utilising the representation of intervals as n*A1
-- + m*d2 (by some linear transformation) to number the resulting
-- degrees of the scale (Rank 1 tuning systems)
edoTune :: AbstractInt3 -> (Int, Int) -> AbstractInt2 -> AbstractInt3
edoTune d (x, y) (AbstractInt2 q n) =
  let a ::+ b = faInt q n
  in (fromIntegral (x*a + y*b)) *^ d

-- Generic function for tunings that are based on fixing the value of
-- two intervals -- i.e. two generators for the whole scale (Rank 2
-- (syntonic) tuning systems)
synTune :: AbstractInt3 -> AbstractInt3 -> AbstractInt2 -> AbstractInt3
synTune a1rat d2rat (AbstractInt2 q n) =
  let a1 ::+ d2 = faInt q n
  in (a1rat ^* (fromIntegral a1)) ^+^ (d2rat ^* (fromIntegral d2))

-- For rank-3 tuning systems (specifically five-limit aka just
-- intonation), see FiveLimit.hs (experimental).

makeBasis i (i1, r1) (i2, r2) = case (intervalDivisorsFrac i i1 i2) of
--   Just (x, y) -> AbstractInt3 $ r1**x * r2**y
  Just (x, y) -> (x *^ r1) ^+^ (y *^ r2)
  Nothing -> error ("Cannot use intervals " ++ (show i1) ++ " and " ++ (show i2) ++ " as basis pair to represent " ++ (show i))

makeA1 = makeBasis _A1
maked2 = makeBasis d2


-- All intervals become unison, so all pitches sound the same
data DummyTuning = DummyTuning (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning DummyTuning AbstractPitch2 AbstractInt2 where
  base (DummyTuning b) = b
  tuneInt _ _ = AbstractInt3 1


---- Syntonic (aka meantone) tunings

-- A note about the syntonic tunings described here: In the real
-- world, when these syntonic/meantone tunings are used on e.g. a
-- keyboard, the number of notes generated by the tuning system has to
-- be fixed to some finite number (typically 12, for normal
-- keyboards). The synTune function below will, however, merrily
-- generate perfectly correct notes/intervals of every kind in every
-- key, producing results that would be impossible in real life (you
-- cannot have a keyboard with a (countably) infinite number of
-- keys). E.g. there is a correct way to tune C-double-sharp (or a
-- doubly-diminished-sixth or what have you) in Pythagorean tuning,
-- but you would never encounter this note unless someone had decided
-- that they *really* wanted a C-double-sharp on their keyboard
-- instead of a D. Therefore, to more accurately represent real-world
-- usage, it may be desirable to write a version of synTune that
-- arbitrarily cut off the number of different notes generated by a
-- particular tuning system (and maybe to give a description of the
-- cutting-off-point(s) as a parameter of the tuning system's type
-- constructor).


data Pythagorean = Pythagorean (AbstractPitch2, AbstractPitch3) deriving Show

pyA1 = makeA1 (_P8, rat 2) (_P5, rat $ 3/2) -- chromatic semitone (is larger than m2, the diatonic semitone)
pyd2 = maked2 (_P8, rat 2) (_P5, rat $ 3/2) -- is equal to comma^(-1), i.e. in negative direction

instance Tuning Pythagorean AbstractPitch2 AbstractInt2 where
  base (Pythagorean b) = b
  tuneInt _ = synTune pyA1 pyd2


-- Quarter-comma meantone
data QCMeanTone = QCMeanTone (AbstractPitch2, AbstractPitch3) deriving Show
-- we know that M3 = 5/4
qcd2 = maked2 (_P8, rat 2) (_M3, rat $ 5/4) -- (diesis)
qcA1 = makeA1 (_P8, rat 2) (_M3, rat $ 5/4)
instance Tuning QCMeanTone AbstractPitch2 AbstractInt2 where
  base (QCMeanTone b) = b
  tuneInt _ = synTune qcA1 qcd2

-- Sixth-comma meantone
data SCMeanTone = SCMeanTone (AbstractPitch2, AbstractPitch3) deriving Show
-- we know that A4 = 45/32
scd2 = maked2 (_P8, rat 2) (_A4, rat $ 45/32)
scA1 = makeA1 (_P8, rat 2) (_A4, rat $ 45/32)
instance Tuning SCMeanTone AbstractPitch2 AbstractInt2 where
  base (SCMeanTone b) = b
  tuneInt _ = synTune scA1 scd2

-- Third-comma meantone
data TCMeanTone = TCMeanTone (AbstractPitch2, AbstractPitch3) deriving Show
-- we know that m3 = 6/5
tcd2 = maked2 (_P8, rat 2) (m3, rat $ 6/5)
tcA1 = makeA1 (_P8, rat 2) (m3, rat $ 6/5)
instance Tuning TCMeanTone AbstractPitch2 AbstractInt2 where
  base (TCMeanTone b) = b
  tuneInt _ = synTune tcA1 tcd2


-- I'll write the rest of the meantone tunings in condensed form

pureoctave = ArbitrarySyntonic (_P8, rat 2)

septimal    = pureoctave (_A6,      rat $ 7/4)
schismatic  = pureoctave (8 *^ _P4, rat $ 10)
kleismic    = pureoctave (6 *^ m3,  rat $ 3)
augmented   = pureoctave (3 *^ _M3, rat $ 2)
pelogic     = pureoctave (4 *^ _P5, rat $ 24/5)
wuerschmidt = pureoctave (8 *^ _M3, rat $ 6)
dimipent    = pureoctave (4 *^ m3,  rat $ 2)
dicot       = pureoctave (_A1,      rat $ 1) -- i.e. TET7
tetracot    = pureoctave (_A5,      rat $ 3/2)
sycamore    = pureoctave (5 *^ _A1, rat $ 6/5)
escapade    = pureoctave (9 *^ _M3, rat $ 16384 / 2187)
vishnuzmic  = pureoctave (7 *^ _A1, rat $ 4/3)
inverted    = pureoctave (_P5,      rat $ 4/3) -- swap fourths and fifths

pureFifthsThirds = ArbitrarySyntonic (_P5, rat $ 3/2) (_M3, rat $ 5/4) -- pure fifths and thirds, but not octaves(!)


data ArbitrarySyntonic = ArbitrarySyntonic
                         (AbstractInt2, AbstractInt3)
                         (AbstractInt2, AbstractInt3)
                         (AbstractPitch2, AbstractPitch3) deriving Show

instance Tuning ArbitrarySyntonic AbstractPitch2 AbstractInt2 where
  base (ArbitrarySyntonic _ _ b) = b
  tuneInt (ArbitrarySyntonic int1 int2 b) = synTune (makeA1 int1 int2) (maked2 int1 int2)



---- Equal-division-of-the-octave (aka TET aka EDO) tunings

-- By analogy with the note about syntonic tuning systems given above,
-- the n-TET tuning systems here are obviously only applicable to
-- keyboards with n different keys -- hence 12-TET being the only one
-- in common usage (but see Costeley.lhs for an interesting 19-TET
-- example).


data TET7 = TET7 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET7 AbstractPitch2 AbstractInt2 where
  base (TET7 b) = b
  tuneInt _ = edoTune (edo 7) (0, 1)
-- this is equivalent to setting A1 = 1, i.e. using
-- ArbitrarySyntonic (_P8, rat $ 2) (_A1, rat $ 1) (a, freq 440)


-- TET12 is an excellent approximation to Pythagorean tuning, and is
-- also very good overall at harmonic-matching. It's *not* as close to
-- Just intonation as many of the Meantone temperaments, however.
type Equal = TET12
equal = TET12
data TET12 = TET12 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET12 AbstractPitch2 AbstractInt2 where
  base (TET12 b) = b
  tuneInt _ = edoTune (edo 12) (1, 0)
-- Note that you can get 12-TET by tempering out the Pythagorean comma, i.e.:
-- TET12 (a, freq 440) == ArbitrarySyntonic (_P8, rat 2) (comma, rat 1) (a, freq 440)
-- where comma = unison ^-^ d2



-- data TET17 -- todo: implement the arabic system of notation/scales,
-- then use TET17 as its tuning system.
data TET17 = TET17 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET17 AbstractPitch2 AbstractInt2 where
  base (TET17 b) = b
  tuneInt _ = edoTune (edo 17) (2, -1)

data TET19 = TET19 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET19 AbstractPitch2 AbstractInt2 where
  base (TET19 b) = b
  tuneInt _ = edoTune (edo 19) (1, 1)


-- data Indian22 -- todo: implement the Indian system of notation/scales,
-- then use this as its tuning system.

-- the EDO-version of Indian22 above (maybe)
data TET22 = TET22 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET22 AbstractPitch2 AbstractInt2 where
  base (TET22 b) = b
  tuneInt _ = edoTune (edo 22) (3, -2)

-- TET12 + quarter-tones:
data TET24 = TET24 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET24 AbstractPitch2 AbstractInt2 where
  base (TET24 b) = b
  tuneInt _ = edoTune (edo 24) (2, 0)


data TET31 = TET31 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET31 AbstractPitch2 AbstractInt2 where
  base (TET31 b) = b
  tuneInt _ = edoTune (edo 31) (2, 1)


data TET34 = TET34 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET34 AbstractPitch2 AbstractInt2 where
  base (TET34 b) = b
  tuneInt _ = edoTune (edo 34) (4, -2)

data TET41 = TET41 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET41 AbstractPitch2 AbstractInt2 where
  base (TET41 b) = b
  tuneInt _ = edoTune (edo 41) (4, -1)


data TET54 = TET54 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET54 AbstractPitch2 AbstractInt2 where
  base (TET54 b) = b
  tuneInt _ = edoTune (edo 54) (1, 6)

-- TET12 divided by 6:
data TET72 = TET72 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET72 AbstractPitch2 AbstractInt2 where
  base (TET72 b) = b
  tuneInt _ = edoTune (edo 72) (6, 0)

data TET94 = TET94 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET94 AbstractPitch2 AbstractInt2 where
  base (TET94 b) = b
  tuneInt _ = edoTune (edo 94) (9, -2)
--  tuneInt _ = edoTune (edo 94) (2, 10)


data TET118 = TET118 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET118 AbstractPitch2 AbstractInt2 where
  base (TET118 b) = b
  tuneInt _ = edoTune (edo 118) (4, 10)



