{-# LANGUAGE EmptyDataDecls, 
             MultiParamTypeClasses, 
             UndecidableInstances, 
             IncoherentInstances, 
             DataKinds,
             FunctionalDependencies,
             FlexibleContexts,
             RankNTypes,
             OverlappingInstances,
             TypeSynonymInstances,
             ScopedTypeVariables,
             UnicodeSyntax,
             GADTSyntax,
             GADTs,
             TypeFamilies,
             ConstraintKinds,
             InstanceSigs,
             GeneralizedNewtypeDeriving,
             StandaloneDeriving,
             ViewPatterns,
             FlexibleInstances #-}

module Tuning (Tuning(..),
               Pythagorean(..),
               Equal(..),
               equal,
               QCMeanTone(..),
               SeptimalMeanTone(..),
               Schismatic(..),
               PureFifthsThirds(..),
               ArbitrarySyntonic(..),
               TET7(..),
               TET12(..),
               TET17(..),
               TET19(..),
               TET22(..),
               TET24(..),
               TET31(..),
               TET54(..),
               TET72(..),
               edo,
               DummyTuning(..)) where

import Prelude hiding (negate)

import Util (interleave)

import Music (Name(..), Accidental(..),
              Quality(..), Number(..),
              AbstractPitch3(..), AbstractInt3(..), AbstractDur3(..),
              AbstractPitch2(..), AbstractInt2(..), AbstractDur2(..),
              AbstractNote(..), Note, Tuning(..), Transpose(..),
              Freq, add, sub, invert, negate, transpose, interval, octave,
              faInt, faPitch, FreeAbelian(..), intToFa, pitchToFa, toInterval, toPitch)

import Algebra
import Shortcuts


-- return an equal division of the octave
edo :: Int -> AbstractInt3
edo n = octave ^* (1/(fromIntegral n))

-- Generic function for EDO tunings -- i.e. one generator for the
-- whole scale, but utilising the representation of intervals as n*A1
-- + m*d2 (by some linear transformation) to number the resulting
-- degrees of the scale (Rank 1 tuning systems)
edoTune :: AbstractInt3 -> (Int, Int) -> AbstractInt2 -> AbstractInt3
edoTune d (x, y) (AbstractInt2 q n) =
  let a ::+ b = faInt q n
  in (fromIntegral (x*a + y*b)) *^ d

-- Generic function for tunings that are based on fixing the value of
-- two intervals -- i.e. two generators for the whole scale (Rank 2
-- (syntonic) tuning systems)
synTune :: AbstractInt3 -> AbstractInt3 -> AbstractInt2 -> AbstractInt3
synTune a1rat d2rat (AbstractInt2 q n) =
  let a1 ::+ d2 = faInt q n
  in (a1rat ^* (fromIntegral a1)) ^+^ (d2rat ^* (fromIntegral d2))

-- For rank-3 tuning systems (specifically five-limit aka just
-- intonation), see FiveLimit.hs (experimental).

makeBasis i (i1, r1) (i2, r2) = case (intervalDivisorsFrac i i1 i2) of
--   Just (x, y) -> AbstractInt3 $ r1**x * r2**y
  Just (x, y) -> (x *^ r1) ^+^ (y *^ r2)
  Nothing -> error ("Cannot use intervals " ++ (show i1) ++ " and " ++ (show i2) ++ " as basis pair to represent " ++ (show i))

makeA1 = makeBasis _A1
maked2 = makeBasis d2


-- All intervals become unison, so all pitches sound the same
data DummyTuning = DummyTuning (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning DummyTuning AbstractPitch2 AbstractInt2 where
  base (DummyTuning b) = b
  tuneInt _ _ = AbstractInt3 1


---- Syntonic (aka meantone) tunings

-- A note about the syntonic tunings described here: In the real
-- world, when these syntonic/meantone tunings are used on e.g. a
-- keyboard, the number of notes generated by the tuning system has to
-- be fixed to some finite number (typically 12, for normal
-- keyboards). The synTune function below will, however, merrily
-- generate perfectly correct notes/intervals of every kind in every
-- key, producing results that would be impossible in real life (you
-- cannot have a keyboard with a (countably) infinite number of
-- keys). E.g. there is a correct way to tune C-double-sharp (or a
-- doubly-diminished-sixth or what have you) in Pythagorean tuning,
-- but you would never encounter this note unless someone had decided
-- that they *really* wanted a C-double-sharp on their keyboard
-- instead of a D. Therefore, to more accurately represent real-world
-- usage, it may be desirable to write a version of synTune that
-- arbitrarily cut off the number of different notes generated by a
-- particular tuning system (and maybe to give a description of the
-- cutting-off-point(s) as a parameter of the tuning system's type
-- constructor).


data Pythagorean = Pythagorean (AbstractPitch2, AbstractPitch3) deriving Show

pythag_A1 = makeA1 (_P8, rat 2) (_P5, rat $ 3/2) -- chromatic semitone (is larger than m2, the diatonic semitone)
pythag_d2 = maked2 (_P8, rat 2) (_P5, rat $ 3/2) -- is equal to comma^(-1), i.e. in negative direction

instance Tuning Pythagorean AbstractPitch2 AbstractInt2 where
  base (Pythagorean b) = b
  tuneInt _ = synTune pythag_A1 pythag_d2


data QCMeanTone = QCMeanTone (AbstractPitch2, AbstractPitch3) deriving Show

-- we know that M3 = 5/4

qcd2 = maked2 (_P8, rat 2) (_M3, rat $ 5/4) -- (diesis)
qcA1 = makeA1 (_P8, rat 2) (_M3, rat $ 5/4)

instance Tuning QCMeanTone AbstractPitch2 AbstractInt2 where
  base (QCMeanTone b) = b
  tuneInt _ = synTune qcA1 qcd2


data SeptimalMeanTone = SeptimalMeanTone (AbstractPitch2, AbstractPitch3)
                      deriving Show

-- We know that A6 = 7/4
smtA1 = makeA1 (_P8, rat 2) (_A6, rat $ 7/4)
smtd2 = maked2 (_P8, rat 2) (_A6, rat $ 7/4)

instance Tuning SeptimalMeanTone AbstractPitch2 AbstractInt2 where
  base (SeptimalMeanTone b) = b
  tuneInt _ = synTune smtA1 smtd2

data Schismatic = Schismatic (AbstractPitch2, AbstractPitch3) deriving Show

-- We know that 8*P4 = 10
schA1 = makeA1 (_P8, rat 2) (8 *^ _P4, rat 10)
schd2 = maked2 (_P8, rat 2) (8 *^ _P4, rat 10)

instance Tuning Schismatic AbstractPitch2 AbstractInt2 where
  base (Schismatic b) = b
  tuneInt _ = synTune schA1 schd2




data PureFifthsThirds = PureFifthsThirds (AbstractPitch2, AbstractPitch3) deriving Show
-- pure fifths and thirds, but not octaves(!!)
instance Tuning PureFifthsThirds AbstractPitch2 AbstractInt2 where
  base (PureFifthsThirds b) = b
  tuneInt _ = synTune
              (makeA1 (_P5, rat $ 3/2) (_M3, rat $ 5/4))
              (maked2 (_P5, rat $ 3/2) (_M3, rat $ 5/4))

data ArbitrarySyntonic = ArbitrarySyntonic
                         (AbstractInt2, AbstractInt3)
                         (AbstractInt2, AbstractInt3)
                         (AbstractPitch2, AbstractPitch3) deriving Show

instance Tuning ArbitrarySyntonic AbstractPitch2 AbstractInt2 where
  base (ArbitrarySyntonic _ _ b) = b
  tuneInt (ArbitrarySyntonic int1 int2 b) = synTune (makeA1 int1 int2) (maked2 int1 int2)



---- Equal-division-of-the-octave (aka TET aka EDO) tunings

-- By analogy with the note about syntonic tuning systems given above,
-- the n-TET tuning systems here are obviously only applicable to
-- keyboards with n different keys -- hence 12-TET being the only one
-- in common usage (but see Costeley.lhs for an interesting 19-TET
-- example).

data TET12 = TET12 (AbstractPitch2, AbstractPitch3) deriving Show
type Equal = TET12
equal = TET12
instance Tuning TET12 AbstractPitch2 AbstractInt2 where
  base (TET12 b) = b
  tuneInt _ = edoTune (edo 12) (1, 0)

-- Note that you can get 12-TET by tempering out the Pythagorean comma, i.e.:
-- TET12 (a, freq 440) == ArbitrarySyntonic (_P8, rat 2) (comma, rat 1) (a, freq 440)
-- where comma = unison ^-^ d2


data TET19 = TET19 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET19 AbstractPitch2 AbstractInt2 where
  base (TET19 b) = b
  tuneInt _ = edoTune (edo 19) (1, 1)


data TET7 = TET7 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET7 AbstractPitch2 AbstractInt2 where
  base (TET7 b) = b
  tuneInt _ = edoTune (edo 7) (0, 1)
-- this is equivalent to setting A1 = 1, i.e. using
-- ArbitrarySyntonic (_P8, rat $ 2) (_A1, rat $ 1) (a, freq 440)


-- data TET17 -- todo: implement the arabic system of notation/scales,
-- then use TET17 as its tuning system.
data TET17 = TET17 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET17 AbstractPitch2 AbstractInt2 where
  base (TET17 b) = b
  tuneInt _ = edoTune (edo 17) (2, -1)

-- data Indian22 -- todo: implement the Indian system of notation/scales,
-- then use this as its tuning system.

-- the EDO-version of Indian22 above (maybe)
data TET22 = TET22 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET22 AbstractPitch2 AbstractInt2 where
  base (TET22 b) = b
  tuneInt _ = edoTune (edo 22) (3, -2)

-- TET12 + quarter-tones:
data TET24 = TET24 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET24 AbstractPitch2 AbstractInt2 where
  base (TET24 b) = b
  tuneInt _ = edoTune (edo 24) (2, 0)


data TET31 = TET31 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET31 AbstractPitch2 AbstractInt2 where
  base (TET31 b) = b
  tuneInt _ = edoTune (edo 31) (2, 1)



-- fixme: the current choices of (x,y) for TET54 and TET72 are
-- obviously nonsense!

data TET54 = TET54 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET54 AbstractPitch2 AbstractInt2 where
  base (TET54 b) = b
  tuneInt _ = edoTune (edo 54) (1, 6)

-- TET12 divided by 6:
data TET72 = TET72 (AbstractPitch2, AbstractPitch3) deriving Show
instance Tuning TET72 AbstractPitch2 AbstractInt2 where
  base (TET72 b) = b
  tuneInt _ = edoTune (edo 72) (6, 0)


-- Zarlino's Just scale uses: makeBasis i (m3, 6/5) (_M3, 5/4)



-- data Ptolemy
--
-- data Just3Limit
-- 
-- data Just5Limit
-- 
